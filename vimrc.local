set tags=./tags;/,~/.vimtags
" Make tags placed in .git/tags file available in all levels of a repository
let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
if gitroot != ''
    let &tags = &tags . ',' . gitroot . '/.git/tags'
endif

au BufRead,BufNewFile *.definition set filetype=xml

" CSApprox {
    let g:CSApprox_attr_map = { 'bold' : 'bold', 'italic' : '', 'sp' : '' }
" }
" bundle settings
" ===============

"autocmd FileType c,cpp,cs,java,go,php,javascript,python,twig,xml,yml autocmd BufWritePre <buffer> if !exists('g:spf13_keep_trailing_whitespace') | call StripTrailingWhitespace() | endif 

" Solarized {
    let g:solarized_termcolors=256
    let g:solarized_termtrans=1
    let g:solarized_contrast="normal"
    let g:solarized_visibility="normal"
"    color solarized             " Load a colorscheme
" }

" unite {
    let g:unite_source_history_yank_enable = 1
    call unite#filters#matcher_default#use(['matcher_fuzzy'])

	" The prefix key.
	nnoremap    [unite]   <Nop>
	nmap        m [unite]

    nnoremap <silent> [unite]t  :<C-u>Unite -buffer-name=files file_rec/async:!<cr>
    nnoremap <silent> [unite]f  :<C-u>Unite -buffer-name=files file<cr>
    nnoremap <silent> [unite]r  :<C-u>Unite -buffer-name=mru file_mru<cr>
    nnoremap <silent> [unite]o  :<C-u>Unite -buffer-name=outline outline<cr>
    nnoremap <silent> [unite]y  :<C-u>Unite -buffer-name=yank history/yank<cr>
    nnoremap <silent> [unite]b  :<C-u>Unite -buffer-name=buffer buffer<cr>
    nnoremap <silent> [unite]a  :<C-u>Unite -buffer-name=all buffer file_mru file/async file_rec/async<CR>
    nnoremap <silent> [unite]mk :<C-u>Unite -buffer-name=bookmark bookmark<cr>
    nnoremap <silent> [unite]c  :<C-u>UniteWithCurrentDir -buffer-name=files buffer file_mru file/async file_rec/async<CR>
    nnoremap <silent> [unite]d  :<C-u>UniteWithBufferDir -buffer-name=files -prompt=%\  buffer file_mru file/async file_rec/async<CR>
    nnoremap <silent> [unite]ma :<C-u>Unite mapping<cr>
    nnoremap <silent> [unite]l  :<C-u>Unite line<CR>
    nnoremap <silent> [unite]z  :<C-u>Unite -buffer-name=resume resume<CR>
    nnoremap <silent> [unite]re  :<C-u>Unite -buffer-name=register register<CR>
    nnoremap <silent> [unite]me :<C-u>Unite output:message<CR>
    nnoremap <silent> [unite]s  :<C-u>Unite source<CR>

    nnoremap <silent> [unite]n  :<C-u>Unite -buffer-name=files jump_point file_point buffer_tab file_rec:! file file/new<CR>

	call unite#custom#profile('default', 'context', {
	\   'start_insert': 1,
    \   'no-split': 1
	\ })

	autocmd FileType unite call s:unite_my_settings()
	function! s:unite_my_settings()"{{{
	  " Overwrite settings.

      imap <buffer> jj      <Plug>(unite_insert_leave)
      " Enable navigation with control-j and control-k in insert mode
      imap <buffer> <C-j>   <Plug>(unite_select_next_line)
      imap <buffer> <C-k>   <Plug>(unite_select_previous_line)

      imap <buffer><expr> j unite#smart_map('j', '')
      imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)

      imap <buffer> '     <Plug>(unite_quick_match_default_action)
      nmap <buffer> '     <Plug>(unite_quick_match_default_action)

      imap <buffer><expr> x unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
      nmap <buffer> x     <Plug>(unite_quick_match_choose_action)

      nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
      imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)

      imap <buffer> <C-y>     <Plug>(unite_narrowing_path)
      nmap <buffer> <C-y>     <Plug>(unite_narrowing_path)

      nmap <buffer> <C-j>     <Plug>(unite_toggle_auto_preview)

      nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
      imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
      nnoremap <silent><buffer><expr> l
                  \ unite#smart_map('l', unite#do_action('default'))

      let unite = unite#get_current_unite()
      if unite.profile_name ==# 'search'
          nnoremap <silent><buffer><expr> r     unite#do_action('replace')
      else
          nnoremap <silent><buffer><expr> r     unite#do_action('rename')
      endif

	  nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
	  nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
	          \ empty(unite#mappings#get_current_filters()) ?
	          \ ['sorter_reverse'] : [])

	  imap <silent><buffer><expr> <C-o>     unite#do_action('split')
	  imap <silent><buffer><expr> <C-v>     unite#do_action('vsplit')
	endfunction"}}}

	if executable('jvgrep')
	  " For jvgrep.
	  let g:unite_source_grep_command = 'jvgrep'
	  let g:unite_source_grep_default_opts = '-i --exclude ''\.(git|svn|hg|bzr)'''
	  let g:unite_source_grep_recursive_opt = '-R'
	endif

	" For ack.
	if executable('ack-grep')
	  " let g:unite_source_grep_command = 'ack-grep'
	  " let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H'
	  " let g:unite_source_grep_recursive_opt = ''
	endif

" }
" neocomplcache {
    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
    autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
" }

" sneak {
    let g:sneak#steak = 1
    nmap f <Plug>SneakForward
    nmap F <Plug>SneakBackward
    xmap f <Plug>VSneakForward
    xmap F <Plug>VSneakBackward
"}

" vim-autoclose
let g:autoclose_vim_commentmode = 1

" bufexplorer {
let g:bufExplorerDefaultHelp=0
let g:bufExplorerSplitBelow=0

" }

" Ultisnips {
    let g:UltiSnipsSnippetDirectories=["UltiSnips", "bundle/vim-snippets/UltiSnips/", "bundle/angular-vim-snippets/UltiSnips"]

    " make YCM compatible with UltiSnips (using supertab)
    let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
    let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
    "let g:SuperTabDefaultCompletionType = '<C-n>'
    let g:ycm_key_invoke_completion = '<c-n>'
    " better key bindings for UltiSnipsExpandTrigger
    let g:UltiSnipsExpandTrigger = "<tab>"
    let g:UltiSnipsJumpForwardTrigger = "<tab>"
    let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" }

" vim-airline {
        " Set configuration options for the statusline plugin vim-airline.
        " Use the powerline theme and optionally enable powerline symbols.
        " To use the symbols , , , , , , and .in the statusline
        " segments add the following to your .vimrc.before.local file:
        "   let g:airline_powerline_fonts=1
        " If the previous symbols do not render for you then install a
        " powerline enabled font.

        let g:airline#extensions#tabline#enabled = 1
        let g:airline#extensions#tabline#buffer_nr_show = 1
        let g:airline#extensions#tmuxline#enabled = 1

        " See `:echo g:airline_theme_map` for some more choices
        " Default in terminal vim is 'dark'
        if !exists('g:airline_theme')
            let g:airline_theme = 'solarized'
        endif
        if !exists('g:airline_powerline_fonts')
            " Use the default set of separators with a few customizations
            let g:airline_left_sep='›'  " Slightly fancier than '>'
            let g:airline_right_sep='‹' " Slightly fancier than '<'
        endif
" }

set background=dark
let g:airline_theme="dark"
if has("gui_running")
    colorscheme hemisu
    if has("gui_gtk2")
       set guifont=Ubuntu\ Mono\ 12 
   elseif has("gui_macvim")
       set guifont=Menlo\ Regular:h11
   elseif has("gui_win32")
       set guifont=Consolas:h11:cANSI
   endif
else
    colorscheme molokai
endif

let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
    \ }

call frisk#AddEngine('gowalker', 'https://gowalker.org/?q=')
call frisk#AddEngine('ddgoog', 'http://www.duckduckgoog.com/?q=')
