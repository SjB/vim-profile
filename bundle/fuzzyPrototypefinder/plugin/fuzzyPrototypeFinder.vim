""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzyPrototypeFinder.vim: Find function/Class/Namespace with a fuzzy pattern
" Last Change: 24-Aug-2007
" Author: SjB <steve@sagacity.ca>
" Version: 0.1, for Vim 7.0
" Licence: MIT License
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" This script uses many function from FuzzyFinder so many 
" Thanks to Takeshi Nishida for FuzzyFinder
"
" Description:
" 	With fuzzyPrototypeFinder, you can quickly reach the
" 	Function/Class/Namespace you want with less typing. FuzzyPrototypeFinder 
" 	use a tags file, generated by the ctag program, to find matching
" 	Function/Class/Namespace to which fuzzyPrototypeFinder converted the
" 	inputting pattern.
"
" Examples:
" 	GCDF ==> GCacheDestroyFunc
" 	cache_new ==> cache_node_new
"	C::C::g_alias ==> Cairo::Context::get_antialias
"
"
" You can map a key to invoke these commands. For example, the following
" command create a normal mode mapping for the <F2> key to search the Global
" list.
"
" 	nnoremap <silent> <F2> :FuzzyPrototypeFinderGlobal<CR>
"	nnoremap <silent> <F3> :FuzzyPrototypeFinderClass<CR>
"	nnoremap <silent> <F4> :FuzzyPrototypeFinderFunction<CR>
"	nnoremap <silent> <F5> :FuzzyPrototypeFinderNamespace<CR>
"
" Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.
"
" Some configuration variables.
"	g:FPF_MinLengthInput (size of the input before search starts
"

if exists("loaded_fuzzyPrototypeFinder") || v:version < 700
	finish
endif
let loaded_fuzzyPrototypeFinder = 1

" Do not complete if a length of input is less than
" FPF_MinLengthBuffer
if !exists('g:FPF_MinLengthInput')
	let g:FPF_MinLengthInput = 3
endif

" If items were matched over this, processing completion is aborted. 
if !exists('g:FPF_CompletionItemLimit')
    let g:FPF_CompletionItemLimit = 100
endif


command! -narg=0 -bar FuzzyPrototypeFinderNamespace call <SID>OpenInputWindow('Namespace', 'n')
command! -narg=0 -bar FuzzyPrototypeFinderClass 	call <SID>OpenInputWindow('Class', 'c')
command! -narg=0 -bar FuzzyPrototypeFinderFunction 	call <SID>OpenInputWindow('Function', 'f')
command! -narg=0 -bar FuzzyPrototypeFinderGlobal	call <SID>OpenInputWindow('Global' ,'')

let s:cmdPrompt = '>'
let s:abortedResult = [{'word': ' ', 'abbr': 'ABORT: Too many matches (> g:FPF_CompletionItemLimit)'}]
let s:kind = ''
let s:bufID = -1
let s:openCommand = ':tag '

function! <SID>OpenInputWindow(search_field, kind)
	
	if strlen(a:search_field)
		let bufferName = "[FuzzyPrototypeFinder " . a:search_field . "]"
		let s:kind = a:kind
	else
		let bufferName = "[FuzzyPrototypeFinder Global]"
		let s:kind = ''
	endif

	let completeFunc = 'FuzzyPrototypeFinder_OmniTagComplete'

	let s:lastInputLength=-1

	if s:bufID != -1
		execute 'buffer' . s:bufID
		delete _
	else
		1new
		let s:bufID = bufnr('%')
	
		let s:_completeopt = &completeopt
		set completeopt=menuone
		setlocal bufhidden=wipe
		setlocal buftype=nofile
		setlocal noswapfile
		setlocal nobuflisted
		setlocal modifiable

		inoremap <buffer> <silent> <expr> <CR> <SID>OnCR()
		inoremap <buffer> <silent> <expr> <BS> pumvisible() ? "\<C-E>\<BS>" : "\<BS>"

		if exists(':AutoComplPopLock')
				:AutoComplPopLock
		endif

		augroup FPF_AudoCommand
				autocmd!
				autocmd InsertLeave <buffer> nested call <SID>OnInsertLeave()
				autocmd CursorMovedI <buffer> call <SID>OnCursorMovedI()
				autocmd BufLeave <buffer> call <SID>OnBufLeave()
		augroup END
	endif
	let &l:completefunc = completeFunc

	execute 'file ' . bufferName

	call feedkeys('i' . s:cmdPrompt, 'n')
endfunction

function! FuzzyPrototypeFinder_OmniTagComplete(findstart, base)
	if a:findstart
		return 0
	endif

	let input = <SID>ExtractPromptedInput(a:base)

	if !input[0] || strlen(input[1]) < g:FPF_MinLengthInput
		echo ""
		return []
	endif

	let res = []

	let patternW = <SID>MakeFuzzyPattern(input[1])
	let patternR = <SID>ConvertWildcardToRegexp(patternW)

	let tags = taglist(patternR)

	echo 'Evaluating...'
	if len(tags) > g:FPF_CompletionItemLimit
			let res = s:abortedResult
			call feedkeys("\<C-P>")
	else
		for tag in tags
				if s:kind == '' || tag['kind'] == s:kind
						let proto = matchstr(tag['cmd'], '\w.*[^\$\/]')
						call add(res, {'word' : tag['name'], 'abbr' : tag['name'], 'menu' : proto, 'info' : tag['filename'], 'kind' : tag['kind']})
				endif
		endfor
		call feedkeys(!empty(res) ? "\<C-P>\<Down>" : "\<C-E>", 'n')
	endif 

	return res
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>OnCR()
    return pumvisible() ? "\<C-Y>\<C-R>=col('.') > strlen(getline('.')) && getline('.') !~ '[\\\\/]$' ? \"\\<CR>\" : \"\"\<CR>" : "\<CR>"
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>OnCursorMovedI()
    let input = <SID>ExtractPromptedInput(getline('1'))
    if line('.') != 1
        " Fix
        call feedkeys("\<Esc>" . s:openCommand . input[1] . "\<CR>", 'n')
        "call feedkeys("\<Esc>:e " . input[1] . "\<CR>", 'n')
        return
    elseif !input[0]
        " a command prompt is removed
        call feedkeys("\<Home>" . s:cmdPrompt . "\<End>", 'n')
        return
    endif

    let deltaInputLength  = strlen(getline('.')) - s:lastInputLength
    let s:lastInputLength = strlen(getline('.'))

    " if the line was changed and cursor is placed on the end of the line
    if deltaInputLength != 0 && col('.') > s:lastInputLength
        call feedkeys("\<C-X>\<C-U>", 'n')
    endif
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function <SID>OnInsertLeave()
	quit
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>OnBufLeave()
    " resume autocomplpop.vim
    if exists(':AutoComplPopUnlock')
        :AutoComplPopUnlock
    endif

    let &completeopt = s:_completeopt
	let s:bufID = -1
    quit " Quit when other window clicked without leaving a insert mode.
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" "str" -> "*s*t*r*" 
function! <SID>MakeFuzzyPattern(in)
    let out = ''

    for char in split(a:in,'\zs')
        if out !~ '[*?]$' && char !~ '[*?]'
            let out .= '*'. char
        else
            let out .= char
        endif
    endfor

    if out !~ '[*?]$'
        return out . '*'
    endif

    return out
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>ConvertWildcardToRegexp(in)
    let out = escape(a:in, '\')
    let out = substitute(out, '*', '\\w*', 'g')
    let out = substitute(out, '?', '\\w'   , 'g')
    let out = substitute(out, '[', '\\['   , 'g')
    return out
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>ExpandCase(in)
    let out = ''
    for char in split(a:in,'\zs')
        if char =~ '\a'
            let out .= '[' . toupper(char) . tolower(char) . ']'
        else
            let out .= char
        endif
    endfor

    return out
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! <SID>ExtractPromptedInput(in)
    if strlen(a:in) < strlen(s:cmdPrompt) ||
                \ a:in[:strlen(s:cmdPrompt) -1] !=# s:cmdPrompt
        return [0, a:in]
    endif

    return [1, a:in[strlen(s:cmdPrompt):]]
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
