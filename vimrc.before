"show minscm status on statusline
function! MinScmStatus()
    if exists('*g:minscm_getStatus')
        return g:minscm_getStatus()
    else
        return ''
    endif
endfunction

" looks <leader>o {
    let g:looks = {}
    let g:looks.dark = {
                \ '_map': 'd',
                \ ':set': 'background=dark',
                \ ':AirlineTheme': 'dark'
                \ }
    let g:looks.light = {
                \ '_map': 'l',
                \ ':set': 'background=light',
                \ ':AirlineTheme': 'light'
                \ }
    let g:looks.molokai = {
                \ '_map': 'm',
                \ ':colorscheme': 'molokai',
                \ ':AirlineTheme': 'molokai'
                \ }
    let g:looks.gruvbox = {
                \ '_map': 't',
                \ ':colorscheme': 'gruvbox',
                \ ':AirlineTheme': 'wombat'
                \ }
    let g:looks.solarize = {
                \ '_map': 's',
                \ ':colorscheme': 'solarized',
                \ ':AirlineTheme': 'solarized'
                \ }
    let g:looks.pigraph = {
                \ '_map': 'p',
                \ ':colorscheme': 'pigraph',
                \ ':AirlineTheme': 'dark'
                \ }
    let g:looks.bubblegum = {
                \ '_map': 'b',
                \ ':colorscheme': 'bubblegum',
                \ ':AirlineTheme': 'bubblegum'
                \ }
    let g:looks.hemisu = {
                \ '_map': 'h',
                \ ':colorscheme': 'hemisu',
                \ ':AirlineTheme': 'dark'
                \ }
" }

set omnifunc=syntaxcomplete#Complete

" omnicppcomplete setting {
    "set completeopt=menuone
    let g:OmniCpp_GlobalScopeSearch=1
    let g:OmniCpp_NamespaceSearch=1
    let g:OmniCpp_DisplayMode=0
    let g:OmniCpp_ShowScopeInAbbr=1
    let g:OmniCpp_ShowPrototypeInAbbr=1
    let g:OmniCpp_ShowAccess=1
    let g:OmniCpp_DefaultNamespaces=["std"]
    let g:OmniCpp_MayCompleteDot=1
    let g:OmniCpp_MayCompleteArrow=1
    let g:OmniCpp_MayCompleteScope=1
    let g:OmniCpp_SelectFirstItem=0
" }

" neocomplet {
    let g:acp_enableAtStartup = 0
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_enable_auto_delimiter = 1
    "let g:neocomplcache_max_list = 15
    let g:neocomplcache_force_overwrite_completefunc = 1
	" AutoComplPop like behavior.
	let g:neocomplcache_enable_auto_select = 1

	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplcache#close_popup()
	inoremap <expr><C-e>  neocomplcache#cancel_popup()
	" Close popup by <Space>.
	inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"

"}

" UndoTree {
    " If undotree is opened, it is likely one wants to interact with it.
    let g:undotree_SetFocusWhenToggle=1
" }

" indent_guides {
    let g:indent_guides_start_level = 2
    let g:indent_guides_guide_size = 1
    let g:indent_guides_enable_on_vim_startup = 0
" }

" CtrlP setting {
"    let g:ctrlp_map = '<c-p>'
"    let g:ctrlp_cmd = 'CtrlPMixed'
    let g:ctrlp_working_path_mode = 'rwa'
    let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'mixed']

" }

" NERD_tree setting {
    let NERDTreeQuitOnOpen=0
    let NERDTreeShowBookmarks=1
    let NERDTreeChDirMode=2
" }

let g:NERDShutUp=1
let b:match_ignorecase = 1

let g:localvimrc_ask = 0

" Ultisnips {
    let g:UltiSnipsSnippetDirectories=["UltiSnips"]
" }
"
" devhelp 
let g:devhelpWordLength=4
let g:devhelpAssistant=0
let g:devhelpSearch=1

if !has("gui")
    let g:CSApprox_loaded = 1
    let g:CSApprox_hook_post = ['hi clear SignColumn']
endif

" http://vim.wikia.com/wiki/Restore_cursor_to_file_position_in_previous_editing_session
" Restore cursor to file position in previous editing session
" To disable this, add the following to your .vimrc.before.local file:
"   let g:spf13_no_restore_cursor = 1
if !exists('g:spf13_no_restore_cursor')
	function! ResCur()
		if line("'\"") <= line("$")
			normal! g`"
			return 1
		endif
	endfunction

	augroup resCur
		autocmd!
		autocmd BufWinEnter * call ResCur()
	augroup END
endif

function! InitializeDirectories()
    let parent = $HOME
    let prefix = 'vim'
    let dir_list = {
                \ 'backup': 'backupdir',
                \ 'views': 'viewdir',
                \ 'swap': 'directory' }

    if has('persistent_undo')
        let dir_list['undo'] = 'undodir'
    endif

    " To specify a different directory in which to place the vimbackup,
    " vimviews, vimundo, and vimswap files/directories, add the following to
    " your .vimrc.before.local file:
    "   let g:spf13_consolidated_directory = <full path to desired directory>
    "   eg: let g:spf13_consolidated_directory = $HOME . '/.vim/'
    if exists('g:spf13_consolidated_directory')
        let common_dir = g:spf13_consolidated_directory . prefix
    else
        let common_dir = parent . '/.' . prefix
    endif

    for [dirname, settingname] in items(dir_list)
        let directory = common_dir . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction
call InitializeDirectories()
